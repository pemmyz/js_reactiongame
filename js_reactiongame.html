<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Browser Reaction Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body, html {
      margin: 0;
      overflow: hidden;
      background: #333; /* Dark gray background for desktop mode */
      width: 100vw;
      height: 100vh;
      font-family: Arial, sans-serif;
    }
    
    #container {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      width: 100%;
    }

    .side-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin: 0 10px;
      z-index: 2;
    }

    /* DEFAULT DESKTOP STATE: Fixed Size */
    canvas {
      background: #000;
      border: 2px solid #555;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      /* Enforce fixed visual size by default */
      width: 800px;
      height: 600px;
      display: block;
    }

    button {
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background: #555;
      color: #fff;
      transition: background 0.2s;
    }
    button:hover {
      background: #777;
    }

    /* Mobile/Fullscreen Trigger Button */
    #mobileBtn {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 9999;
      background: #007bff;
      opacity: 0.8;
    }
    #mobileBtn:hover {
      opacity: 1;
      background: #0056b3;
    }

    /* --- FULLSCREEN MODE CSS --- */
    /* When active, hide UI and change background to black */
    :fullscreen body, ::-webkit-full-screen body {
        background: #000;
    }
    
    :fullscreen .side-buttons, ::-webkit-full-screen .side-buttons {
        display: none;
    }

    /* In fullscreen, we remove the fixed pixel width so JS can scale it */
    :fullscreen canvas, ::-webkit-full-screen canvas {
        width: auto;
        height: auto;
        border: none;
    }
  </style>
</head>
<body>
  
  <button id="mobileBtn" onclick="goFull()">Switch to mobile</button>

  <div id="container">
    <div class="side-buttons">
      <button id="btnMode">Mode (N)</button>
      <button id="btnPause">Pause (P)</button>
      <button id="btnReset">Reset (R)</button>
      <button id="btnDark">Dark Mode (B)</button>
      <button id="btnExit">Exit (Esc)</button>
      <button id="btnGitHub">GitHub (W)</button>
    </div>
    
    <!-- Restored explicit width/height for default desktop behavior -->
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div class="side-buttons">
      <button id="btnModeR">Mode (N)</button>
      <button id="btnPauseR">Pause (P)</button>
      <button id="btnResetR">Reset (R)</button>
      <button id="btnDarkR">Dark Mode (B)</button>
      <button id="btnExitR">Exit (Esc)</button>
      <button id="btnGitHubR">GitHub (W)</button>
    </div>
  </div>

  <script>
    // --- Constants ---
    const WIDTH = 800;  // Logical game width
    const HEIGHT = 600; // Logical game height
    const SQUARE_SIZE = 50;
    const MAX_SQUARES = 10;
    const TIME_LIMIT = 5;

    // --- Colors ---
    const WHITE = "#FFFFFF";
    const BLACK = "#000000";
    const RED = "#FF0000";

    // --- Canvas Setup ---
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const container = document.getElementById("container");

    // Scale Handling
    let scale = 1;

    // --- Fullscreen / Layout Logic ---
    function goFull() {
      const el = document.documentElement;
      if (el.requestFullscreen) {
        el.requestFullscreen();
      } else if (el.webkitRequestFullscreen) { // Safari/Android fallback
        el.webkitRequestFullscreen();
      }
    }

    function updateLayout() {
      // Check if we are currently in fullscreen mode
      const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;

      if (isFullscreen) {
        // --- MOBILE/FULLSCREEN MODE (Zoom to Fit) ---
        const w = window.innerWidth;
        const h = window.innerHeight;
        
        // Calculate scale to fit screen while maintaining 800x600 aspect ratio
        const scaleX = w / WIDTH;
        const scaleY = h / HEIGHT;
        scale = Math.min(scaleX, scaleY);

        // Resize the internal canvas resolution to keep graphics sharp at large sizes
        canvas.width = WIDTH * scale;
        canvas.height = HEIGHT * scale;
        
        // Set visual size
        canvas.style.width = (WIDTH * scale) + "px";
        canvas.style.height = (HEIGHT * scale) + "px";

        // Apply transform so drawing logic still thinks it's 800x600
        ctx.setTransform(scale, 0, 0, scale, 0, 0);

      } else {
        // --- DESKTOP MODE (Restored Fixed 800x600) ---
        scale = 1;
        
        // Reset internal size
        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        
        // Reset visual size (handled by CSS, but good to ensure)
        canvas.style.width = "800px";
        canvas.style.height = "600px";

        // Reset transform
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
    }

    // Listen for resize and fullscreen changes
    window.addEventListener("resize", updateLayout);
    document.addEventListener("fullscreenchange", updateLayout);
    document.addEventListener("webkitfullscreenchange", updateLayout);
    
    // Initial call
    updateLayout();

    // --- Date Check ---
    const today = new Date();
    const isAprilFools = today.getMonth() === 3 && today.getDate() === 1;

    // --- State Variables ---
    let mode = "classic", paused = false, running = true, darkMode = true;
    let squares = [], squaresClicked = 0, squaresExpired = 0, misclicks = 0, totalPrompts = 0;
    let reactionTimes = [], currentStreak = 0, longestStreak = 0;
    let startTime = getTime(), unpausedTime = 0, lastFrameTime = getTime();
    let followMode = false, followModeThreshold = isAprilFools ? (Math.floor(Math.random() * 16) + 10) : null;
    let afPauseMode = false, afDisabled = false;
    let mousePos = { x: 0, y: 0 };

    // --- Helpers ---
    function getTime() { return performance.now() / 1000; }

    function resetGame() {
      squares = [];
      squaresClicked = 0;
      squaresExpired = 0;
      misclicks = 0;
      totalPrompts = 0;
      reactionTimes = [];
      currentStreak = 0;
      longestStreak = 0;
      startTime = getTime();
      unpausedTime = 0;
      lastFrameTime = getTime();
      paused = false;
      afPauseMode = false;
      if (!afDisabled && isAprilFools) {
        followMode = false;
        followModeThreshold = Math.floor(Math.random() * 16) + 10;
      } else {
        followMode = false;
        followModeThreshold = null;
      }
    }

    function createSquare() {
      const x = Math.random() * (WIDTH - SQUARE_SIZE);
      const y = Math.random() * (HEIGHT - SQUARE_SIZE);
      const createdAt = getTime();
      totalPrompts++;
      return { x, y, size: SQUARE_SIZE, createdAt };
    }

    function removeExpiredSquares() {
      const now = getTime();
      let expired = false;
      squares = squares.filter(sq => {
        if (now - sq.createdAt > TIME_LIMIT) {
          squaresExpired++;
          expired = true;
          return false;
        }
        return true;
      });
      if (expired) currentStreak = 0;
    }

    function computeReactionStats() {
      if (reactionTimes.length === 0) return null;
      const fastest = Math.min(...reactionTimes);
      const slowest = Math.max(...reactionTimes);
      const average = reactionTimes.reduce((a, b) => a + b, 0) / reactionTimes.length;
      const sorted = [...reactionTimes].sort((a, b) => a - b);
      const median = sorted.length % 2 === 0
        ? (sorted[sorted.length/2 - 1] + sorted[sorted.length/2]) / 2
        : sorted[Math.floor(sorted.length/2)];
      let stdev = 0;
      if (reactionTimes.length > 1) {
        const mean = average;
        const diffs = reactionTimes.map(rt => (rt - mean) ** 2);
        stdev = Math.sqrt(diffs.reduce((a, b) => a + b, 0) / (reactionTimes.length - 1));
      }
      const n = sorted.length;
      const p25 = sorted[Math.floor(0.25 * (n - 1))];
      const p75 = sorted[Math.floor(0.75 * (n - 1))];
      return { fastest, slowest, average, median, stdev, p25, p75 };
    }

    // --- Drawing ---
    function drawSquares() {
      ctx.fillStyle = RED;
      squares.forEach(sq => ctx.fillRect(sq.x, sq.y, sq.size, sq.size));
    }

    function drawStats() {
      const elapsed = Math.floor(getTime() - startTime);
      const totalTime = (paused ? lastFrameTime : getTime()) - startTime;
      const totalResp = squaresClicked + squaresExpired + misclicks;
      const accuracy = totalResp ? (squaresClicked / totalResp * 100) : 0;
      const cps = (getTime() - startTime) ? squaresClicked / (getTime() - startTime) : 0;

      ctx.fillStyle = darkMode ? WHITE : BLACK;
      ctx.font = "16px Arial";
      let y = 20;
      const lines = [];

      let modeLabel = mode.toUpperCase();
      if (isAprilFools && !afDisabled) modeLabel += " (AF)";

      lines.push(`Mode: ${modeLabel} (Press N to toggle mode)`);
      lines.push(`Paused: ${paused} (Press P to toggle pause)`);
      lines.push(`Dark Mode: ${darkMode ? 'ON' : 'OFF'} (Press B to toggle dark mode)`);
      lines.push(`Time Played: ${elapsed}s | Clicks/Second: ${cps.toFixed(2)}`);
      lines.push(`Total Game Time: ${totalTime.toFixed(2)}s | Unpaused Time: ${unpausedTime.toFixed(2)}s`);
      lines.push(`Squares Clicked: ${squaresClicked} | Expired: ${squaresExpired} | Misclicks: ${misclicks} | Total Prompts: ${totalPrompts}`);
      lines.push(`Accuracy: ${accuracy.toFixed(2)}%`);
      lines.push(`Current Streak: ${currentStreak} | Longest Streak: ${longestStreak}`);

      const stats = computeReactionStats();
      if (stats) {
        lines.push(`Fastest: ${stats.fastest.toFixed(2)}s | Slowest: ${stats.slowest.toFixed(2)}s`);
        lines.push(`Average: ${stats.average.toFixed(2)}s | Median: ${stats.median.toFixed(2)}s`);
        lines.push(`Std Dev: ${stats.stdev.toFixed(2)}s | 25th: ${stats.p25.toFixed(2)}s | 75th: ${stats.p75.toFixed(2)}s`);
      }

      if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        lines.push("Key Hints: N - Mode, P - Pause, R - Reset, B - Dark Mode, Esc - Exit, W - GitHub");
      } else {
        lines.push("Tap 'Switch to Mobile' again or press ESC to exit fullscreen");
      }

      lines.forEach(line => {
        ctx.fillText(line, 10, y);
        y += 20;
      });
    }

    // --- Utility ---
    function distanceToRect(pt, rect) {
      const dx = Math.max(rect.x - pt.x, 0, pt.x - (rect.x + rect.size));
      const dy = Math.max(rect.y - pt.y, 0, pt.y - (rect.y + rect.size));
      return Math.sqrt(dx * dx + dy * dy);
    }

    // --- Main Loop ---
    function gameLoop() {
      if (!running) return;

      const now = getTime();
      const dt = now - lastFrameTime;
      lastFrameTime = now;

      if (!paused) {
        unpausedTime += dt;
        if (mode === "classic") {
          if (squares.length === 0) squares.push(createSquare());
        } else if (mode === "hyper") {
          if (squares.length < MAX_SQUARES) squares.push(createSquare());
        } else { // superEasy
          if (squares.length === 0) {
            totalPrompts++;
            squares.push({ x: mousePos.x - SQUARE_SIZE/2, y: mousePos.y - SQUARE_SIZE/2, size: SQUARE_SIZE, createdAt: now });
          } else {
            squares[0].x = mousePos.x - SQUARE_SIZE/2;
            squares[0].y = mousePos.y - SQUARE_SIZE/2;
          }
        }
        if (mode !== "superEasy") removeExpiredSquares();
      }

      if (isAprilFools && !afDisabled && !followMode && currentStreak >= followModeThreshold) {
        followMode = true;
      }
      if (isAprilFools && !afDisabled && followMode) {
        squares = squares.filter(sq => {
          if (distanceToRect(mousePos, sq) <= 65) {
            squaresExpired++;
            currentStreak = 0;
            return false;
          }
          return true;
        });
      }

      // --- 3. DRAWING ---
      ctx.fillStyle = darkMode ? BLACK : WHITE;
      // We fillRect using logical coordinates (WIDTH/HEIGHT) because transformation is handled by updateLayout
      ctx.fillRect(0, 0, WIDTH, HEIGHT); 
      
      drawSquares();
      drawStats();

      if (paused) {
        ctx.fillStyle = darkMode ? WHITE : BLACK;
        ctx.font = "30px Arial";
        const msg = afPauseMode ? "Press O to continue" : "Paused";
        const w = ctx.measureText(msg).width;
        ctx.fillText(msg, (WIDTH - w)/2, HEIGHT/2);
      }

      requestAnimationFrame(gameLoop);
    }

    // --- Event Handling ---
    function handleInteraction(clientX, clientY) {
        if (paused) return;
        const rect = canvas.getBoundingClientRect();
        
        // Convert screen coordinates to native 800x600 game coordinates
        // If scale is 1 (desktop), this works normally. If scaled (mobile), this adjusts for the zoom.
        const pos = { 
            x: (clientX - rect.left) / scale, 
            y: (clientY - rect.top) / scale 
        };

        if (mode === "superEasy" && squares.length > 0) {
            squaresClicked++;
            reactionTimes.push(getTime() - squares[0].createdAt);
            currentStreak++;
            if (currentStreak > longestStreak) longestStreak = currentStreak;
            squares[0].createdAt = getTime();
            return;
        }

        const hitIndex = squares.findIndex(sq =>
            pos.x >= sq.x && pos.x <= sq.x + sq.size &&
            pos.y >= sq.y && pos.y <= sq.y + sq.size);
            
        if (hitIndex !== -1) {
            squaresClicked++;
            reactionTimes.push(getTime() - squares[hitIndex].createdAt);
            squares.splice(hitIndex, 1);
            currentStreak++;
            if (currentStreak > longestStreak) longestStreak = currentStreak;
        } else {
            misclicks++;
            currentStreak = 0;
        }
    }

    canvas.addEventListener("mousedown", e => {
        e.preventDefault();
        handleInteraction(e.clientX, e.clientY);
    });

    canvas.addEventListener("touchstart", e => {
        e.preventDefault();
        const touch = e.touches[0];
        handleInteraction(touch.clientX, touch.clientY);
    }, { passive: false });


    canvas.addEventListener("mousemove", event => {
      const rect = canvas.getBoundingClientRect();
      // Adjust mouse pos by scale for "superEasy" mode tracking
      mousePos.x = (event.clientX - rect.left) / scale;
      mousePos.y = (event.clientY - rect.top) / scale;
    });

    function togglePause() {
      paused = !paused;
      if (!paused) lastFrameTime = getTime();
    }

    function handleOKey() {
      if (afPauseMode) {
        afDisabled = true;
        afPauseMode = false;
        paused = false;
        resetGame();
        mode = "classic";
      } else if (isAprilFools && !afDisabled && followMode && squaresExpired >= 35) {
        followMode = false;
        afPauseMode = true;
        paused = true;
      }
    }

    document.addEventListener("keydown", event => {
      const key = event.key.toLowerCase();
      if (key === "n") toggleMode();
      else if (key === "p") togglePause();
      else if (key === "r") resetGame();
      else if (key === "b") darkMode = !darkMode;
      else if (event.key === "Escape") running = false;
      else if (key === "w") window.open("https://github.com/pemmyz/js_reactiongame", "_blank");
      else if (key === "o") handleOKey();
    });

    function toggleMode() {
      mode = mode === "classic" ? "hyper" : mode === "hyper" ? "superEasy" : "classic";
      resetGame();
    }

    // --- Button Wiring ---
    [
      ['btnMode', toggleMode], ['btnModeR', toggleMode],
      ['btnPause', togglePause], ['btnPauseR', togglePause],
      ['btnReset', resetGame], ['btnResetR', resetGame],
      ['btnDark', () => darkMode = !darkMode], ['btnDarkR', () => darkMode = !darkMode],
      ['btnExit', () => running = false], ['btnExitR', () => running = false],
      ['btnGitHub', () => window.open("https://github.com/pemmyz/js_reactiongame", "_blank")],
      ['btnGitHubR', () => window.open("https://github.com/pemmyz/js_reactiongame", "_blank")]
    ].forEach(([id, fn]) => {
      document.getElementById(id).addEventListener('click', fn);
    });

    // --- Start ---
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
